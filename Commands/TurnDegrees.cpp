// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "TurnDegrees.h"
#include <math.h>
TurnDegrees::TurnDegrees()
{
   printf("In Turn Degrees Constructor\n");
   // Use requires() here to declare subsystem dependencies
   // eg. requires(chassis);
   // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::drivetrain);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
   // initialize PID controller
   // Note: There is no range of the input because there is no min/max range of the gyro.
   // and setting the range of the output is unnesscesary because it defaults to -1 to 1.
   m_PIDcontroller = new PIDController(0.0, 0.0, 0.0, Robot::drivetrain->drivetrainGyro,
                                       Robot::drivetrain);
   
   // Set the threshold for the turn controller
   SetThreshold(DEGREES_090 / 20.0f);  // within 4.5 degrees
  
   // The controller is not in range.
   m_inRange = false;
   
   // Create the timer for in range checking
   m_timer = new Timer;
   
   // set the default turn to zero
   m_turnDegrees = 0;
}
TurnDegrees::TurnDegrees(float degrees) 
{
   // call the default constructur
   TurnDegrees();
   
   // remember the degrees to turn
   m_turnDegrees = degrees;
}
// Called just before this Command runs the first time
void TurnDegrees::Initialize() 
{
   // set the PID gain for the controller
   m_PIDcontroller->SetPID(m_Pgain, m_Igain, m_Dgain);
   
   // The controller is not in range.
   m_inRange = false;
     
   // ensure the timer is stopped (used to ensure in range for specified time)
   m_timer->Stop();
   m_timer->Reset();
   
   // read gyro angle
   m_startGyroAngle = Robot::drivetrain->drivetrainGyro->GetAngle();
   m_setPoint = m_startGyroAngle + m_turnDegrees;
   
   // tell the PID controller to 1target angle
   m_PIDcontroller->SetSetpoint(m_setPoint);
   
   // run the PID controller
   m_PIDcontroller->Enable();
}
// Called repeatedly when this Command is scheduled to run
void TurnDegrees::Execute() 
{
   // do nothing since PID is running in its own thread
   
   // show the turn angle error
   SmartDashboard::PutNumber("PID Error", GetPIDError());	
}
// Make this return true when this Command no longer needs to run execute()
bool TurnDegrees::IsFinished() 
{
   // check if turn angle is with range for the first time
   if ((IsOnTarget() == true) && (m_inRange == false))
   {
      // reset the timer to ensure the angle is in range for the settling time
      m_timer->Reset();
      
      // restart the timer
      m_timer->Start();
      
      // angle is in range for the "first" time
      m_inRange = true;
   }
   else if (IsOnTarget() == false)
   {
      // angle is not in the acceptale range for stop the timer
      m_timer->Stop();
      
      // indicate that the angle is out of range
      m_inRange = false;
   }
   
   // return true when on target
   return m_timer->HasPeriodPassed(DRIVE_TRAIN_IN_RANGE_TIME);
}
// Called once after isFinished returns true
void TurnDegrees::End() 
{
   // stop the PID 
   m_PIDcontroller->Disable();
   
   // Stop the timer
   m_timer->Stop();
   m_timer->Reset();	
}
// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void TurnDegrees::Interrupted() 
{
   // call the end method
   End();
}
// Get the error between the target setpoint and the actual location
float TurnDegrees::GetPIDError()
{
  return m_setPoint - Robot::drivetrain->drivetrainGyro->GetAngle();
}
// Check to see if the position is on target.
bool TurnDegrees::IsOnTarget()
{
   return fabs(GetPIDError()) < m_threshold;
}
// Set the Threshold to be considered on target.
void TurnDegrees::SetThreshold(float threshold)
{
   m_threshold = threshold;
}
// Set the PID values of the controller
void TurnDegrees::SetPID(float p, float i, float d)
{
   m_Pgain = p;
   m_Igain = i;
   m_Dgain = d;
   printf("Set PID %f, %f, %f\n", m_Pgain, m_Igain, m_Dgain);
   m_PIDcontroller->SetPID(m_Pgain, m_Igain, m_Dgain);
}
// Delete the PID controller when the class destructs.
TurnDegrees::~TurnDegrees()
{
   delete m_PIDcontroller;
}
