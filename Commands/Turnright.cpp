// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "Turnright.h"
#include <math.h>
#define P_DEFAULT           5.0f
#define I_DEFAULT           0.0f
#define D_DEFAULT           0.0f
#define DEGREES_180         1.0f
#define DEGREES_090         0.5f

#define IN_RANGE_TIME		1.0f

Turnright::Turnright()
{
   // initialize PID controller
   // Note: There is no range of the input because there is no min/max range of the gyro.
   // and setting the range of the output is unnesscesary because it defaults to -1 to 1.
   
   // set the turn tolerance
   // Note: cannot use SetTolerance because the min and max of the input have not been set.
   // must instead use set abs tolerance which takes a distance as it parameter
   
   m_PIDcontroller = new PIDController(P_DEFAULT, I_DEFAULT, D_DEFAULT, Robot::orientation->gyro,
                                              Robot::drivetrain);
   // Set the threshold for the turn controller
   SetThreshold(DEGREES_090 / 20.0f);
   
   // The controller is not in range.
   m_inRange = false;
   
   // Create the timer for in range checking
   m_timer = new Timer;
   
   // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
   Requires(Robot::drivetrain);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}

// Called just before this Command runs the first time
void Turnright::Initialize()
{
   // read gyro angle
   m_startGyroAngle = Robot::orientation->gyro->GetAngle();
   m_setPoint = m_startGyroAngle + DEGREES_090;
   
   // tell the PID controller to target angle
   m_PIDcontroller->SetSetpoint(m_setPoint);
   
   // run the PID controller
   m_PIDcontroller->Enable();
}

// Called repeatedly when this Command is scheduled to run
void Turnright::Execute() 
{
   // do nothing since PID is running in its own thread
   
   // show the turn angle error
   SmartDashboard::PutNumber("PID Error", GetPIDError());
}

// Make this return true when this Command no longer needs to run execute()
bool Turnright::IsFinished() 
{
	if (GetOnTarget() && m_inRange == false)
	{
		m_timer->Reset();
		m_timer->Start();
		m_inRange = true;
	}
	else if (!GetOnTarget())
	{
		m_timer->Stop();
		m_inRange = false;
	}
   
   // return true when on target
	return m_timer->HasPeriodPassed(IN_RANGE_TIME);
}
// Called once after isFinished returns true
void Turnright::End() 
{
   // stop the PID 
	m_PIDcontroller->Disable();
	
	// Stop the timer
	m_timer->Stop();
	m_timer->Reset();
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void Turnright::Interrupted() 
{
   // stop the PID 
   m_PIDcontroller->Disable();
   
	// Stop the timer
	m_timer->Stop();
	m_timer->Reset();
}

// Get the error between the target setpoint and the actual location
float Turnright::GetPIDError()
{
  return m_setPoint - Robot::orientation->gyro->GetAngle();
}

// Check to see if the position is on target.
bool Turnright::GetOnTarget()
{
   return fabs(GetPIDError()) < m_threshold;
}

// Set the Threshold to be considered on target.
void Turnright::SetThreshold(float threshold)
{
   m_threshold = threshold;
}

// Set the PID values of the controller
void Turnright::SetPID(float p, float i, float d)
{
   printf("Set PID %f, %f, %f\n", p, i, d);
   m_PIDcontroller->SetPID(p, i, d);
}

// Delete the PID controller when the class destructs.
Turnright::~Turnright()
{
   delete m_PIDcontroller;
}
